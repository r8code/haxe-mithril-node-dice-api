// Generated by Haxe 3.4.0
if (process.version < "v4.0.0") console.warn("Module " + (typeof(module) == "undefined" ? "" : module.filename) + " requires node.js version 4.0.0 or higher");
(function () { "use strict";
function $extend(from, fields) {
	function Inherit() {} Inherit.prototype = from; var proto = new Inherit();
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var EReg = function() { };
var HxOverrides = function() { };
HxOverrides.cca = function(s,index) {
	var x = s.charCodeAt(index);
	if(x != x) {
		return undefined;
	}
	return x;
};
HxOverrides.iter = function(a) {
	return { cur : 0, arr : a, hasNext : function() {
		return this.cur < this.arr.length;
	}, next : function() {
		return this.arr[this.cur++];
	}};
};
var Lambda = function() { };
Lambda.map = function(it,f) {
	var l = new List();
	var x = $iterator(it)();
	while(x.hasNext()) {
		var x1 = x.next();
		l.add(f(x1));
	}
	return l;
};
var List = function() {
	this.length = 0;
};
List.prototype = {
	add: function(item) {
		var x = new _$List_ListNode(item,null);
		if(this.h == null) {
			this.h = x;
		} else {
			this.q.next = x;
		}
		this.q = x;
		this.length++;
	}
	,iterator: function() {
		return new _$List_ListIterator(this.h);
	}
};
var _$List_ListNode = function(item,next) {
	this.item = item;
	this.next = next;
};
var _$List_ListIterator = function(head) {
	this.head = head;
};
_$List_ListIterator.prototype = {
	hasNext: function() {
		return this.head != null;
	}
	,next: function() {
		var val = this.head.item;
		this.head = this.head.next;
		return val;
	}
};
var Server = function() { };
Server.main = function() {
	var port = 3000;
	var app = new js_npm_Express();
	app["use"](js_npm_express_BodyParser.json({ limit : "5mb", type : "application/json"}));
	app["use"](new js_npm_express_Static("build/client"));
	app.all("*",function(req,res,next) {
		var origin = req.get("origin");
		res.setHeader("Access-Control-Allow-Origin",origin);
		res.setHeader("Access-Control-Allow-Headers","X-Requested-With");
		res.setHeader("Access-Control-Allow-Headers","Content-Type");
		next();
	});
	utils_Routes.route(app);
	app.listen(port);
	console.log("Now listening on port " + port + ".");
};
var Std = function() { };
Std.parseInt = function(x) {
	var v = parseInt(x,10);
	if(v == 0 && (HxOverrides.cca(x,1) == 120 || HxOverrides.cca(x,1) == 88)) {
		v = parseInt(x);
	}
	if(isNaN(v)) {
		return null;
	}
	return v;
};
var haxe_io_Bytes = function() { };
var js__$Boot_HaxeError = function(val) {
	Error.call(this);
	this.val = val;
	this.message = String(val);
	if(Error.captureStackTrace) {
		Error.captureStackTrace(this,js__$Boot_HaxeError);
	}
};
js__$Boot_HaxeError.wrap = function(val) {
	if((val instanceof Error)) {
		return val;
	} else {
		return new js__$Boot_HaxeError(val);
	}
};
js__$Boot_HaxeError.__super__ = Error;
js__$Boot_HaxeError.prototype = $extend(Error.prototype,{
});
var js_node_buffer_Buffer = require("buffer").Buffer;
var js_npm_Express = require("express");
var js_npm_express_BodyParser = require("body-parser");
var js_npm_express__$Route_Route_$Impl_$ = {};
js_npm_express__$Route_Route_$Impl_$.fromEReg = function(e) {
	return e.r;
};
var js_npm_express_Static = require("express").static;
var utils_MathUtil = function(_res) {
	this.res = _res;
};
utils_MathUtil.prototype = {
	handleError: function(rollValue) {
		this.res.status(500).send("Invalid dice expression - " + rollValue);
		throw new js__$Boot_HaxeError("Invalid dice expression: " + rollValue);
	}
	,rollDie: function(min,max) {
		min = Math.ceil(min);
		max = Math.floor(max);
		return Math.floor(Math.random() * (max - min + 1)) + min;
	}
	,oneDieRoll: function(rollValue) {
		var rollRegex = new RegExp("^d([1-8])$").exec(rollValue);
		var rollNum = 0;
		if(rollRegex == null) {
			this.handleError(rollValue);
		} else {
			if(rollRegex[1] != null) {
				rollNum = Std.parseInt(rollRegex[1]);
			} else {
				this.handleError(rollValue);
			}
			return { rollValue : this.rollDie(1,rollNum)};
		}
		return { rollValue : this.rollDie(1,rollNum)};
	}
	,rollDice: function(rollValue) {
		var rollRegex = new RegExp("^([0-9]*)?d([1-8])$").exec(rollValue);
		var rollNum = 0;
		var diceNum = 0;
		var diceGroup = [];
		var rollTotal = 0;
		if(rollRegex == null) {
			this.handleError(rollValue);
		} else {
			if(rollRegex[1] != null) {
				diceNum = Std.parseInt(rollRegex[1]);
			} else {
				this.handleError(rollValue);
			}
			if(rollRegex[2] != null) {
				rollNum = Std.parseInt(rollRegex[2]);
			} else {
				this.handleError(rollValue);
			}
			var _g1 = 0;
			var _g = diceNum;
			while(_g1 < _g) {
				var i = _g1++;
				var roll = this.rollDie(1,rollNum);
				rollTotal += roll;
				diceGroup.push({ rollValue : roll});
			}
			return { diceGroup : diceGroup, rollTotal : rollTotal};
		}
		return { diceGroup : diceGroup, rollTotal : rollTotal};
	}
	,dropLowestRolls: function(rollValue) {
		var rollRegex = new RegExp("^([0-9]*)?d([1-8])?d([1-8])$").exec(rollValue);
		var rollNum = 0;
		var diceNum = 0;
		var dropNum = 0;
		var diceIntGroup = [];
		var rollTotal = 0;
		if(rollRegex == null) {
			this.handleError(rollValue);
		} else {
			if(rollRegex[1] != null) {
				diceNum = Std.parseInt(rollRegex[1]);
			} else {
				this.handleError(rollValue);
			}
			if(rollRegex[2] != null) {
				rollNum = Std.parseInt(rollRegex[2]);
			}
			if(rollRegex[3] != null) {
				dropNum = Std.parseInt(rollRegex[3]);
			} else {
				this.handleError(rollValue);
			}
			var _g1 = 0;
			var _g = diceNum;
			while(_g1 < _g) {
				var i = _g1++;
				var roll = this.rollDie(1,rollNum);
				diceIntGroup.push(roll);
			}
			diceIntGroup.sort(function(a,b) {
				if(a < b) {
					return -1;
				} else if(a > b) {
					return 1;
				} else {
					return 0;
				}
			});
			diceIntGroup = diceIntGroup.slice(0,diceIntGroup.length - dropNum);
			Lambda.map(diceIntGroup,function(value) {
				rollTotal += value;
			});
			return { diceGroup : diceIntGroup, rollTotal : rollTotal, dropped : dropNum};
		}
		return { diceGroup : diceIntGroup, rollTotal : rollTotal, dropped : dropNum};
	}
	,keepHighestRolls: function(rollValue) {
		var rollRegex = new RegExp("^([0-9]*)?d([1-8])?k([1-8])$").exec(rollValue);
		var rollNum = 0;
		var diceNum = 0;
		var keepNum = 0;
		var rollTotal = 0;
		var diceIntGroup = [];
		var rollTotal1 = 0;
		if(rollRegex == null) {
			this.handleError(rollValue);
		} else {
			if(rollRegex[1] != null) {
				diceNum = Std.parseInt(rollRegex[1]);
			} else {
				this.handleError(rollValue);
			}
			if(rollRegex[2] != null) {
				rollNum = Std.parseInt(rollRegex[2]);
			}
			if(rollRegex[3] != null) {
				keepNum = Std.parseInt(rollRegex[3]);
			} else {
				this.handleError(rollValue);
			}
			var _g1 = 0;
			var _g = diceNum;
			while(_g1 < _g) {
				var i = _g1++;
				var roll = this.rollDie(1,rollNum);
				diceIntGroup.push(roll);
			}
			var _g11 = 0;
			var _g2 = diceNum;
			while(_g11 < _g2) {
				var i1 = _g11++;
				var roll1 = this.rollDie(1,rollNum);
				diceIntGroup.push(roll1);
			}
			diceIntGroup.sort(function(a,b) {
				if(a > b) {
					return -1;
				} else if(a < b) {
					return 1;
				} else {
					return 0;
				}
			});
			diceIntGroup = diceIntGroup.slice(0,keepNum);
			Lambda.map(diceIntGroup,function(value) {
				rollTotal1 += value;
			});
			return { diceGroup : diceIntGroup, rollTotal : rollTotal1, kept : keepNum};
		}
		return { diceGroup : diceIntGroup, rollTotal : rollTotal1, kept : keepNum};
	}
	,explosiveRoll: function(rollValue) {
		var rollRegex = new RegExp("^([0-9]*)?d([1-8])?x([1-8])$").exec(rollValue);
		var rollNum = 0;
		var diceNum = 0;
		var explodedNum = 0;
		var exploded = 0;
		var diceIntGroup = [];
		var rollTotal = 0;
		if(rollRegex == null) {
			this.handleError(rollValue);
		} else {
			if(rollRegex[1] != null) {
				diceNum = Std.parseInt(rollRegex[1]);
			} else {
				this.handleError(rollValue);
			}
			if(rollRegex[2] != null) {
				rollNum = Std.parseInt(rollRegex[2]);
			}
			if(rollRegex[3] != null) {
				explodedNum = Std.parseInt(rollRegex[3]);
			} else {
				this.handleError(rollValue);
			}
			var _g1 = 0;
			var _g = diceNum;
			while(_g1 < _g) {
				var i = _g1++;
				var roll = this.rollDie(1,rollNum);
				if(roll < explodedNum) {
					rollTotal += roll;
					diceIntGroup.push(roll);
				} else {
					while(roll > explodedNum) {
						++exploded;
						roll = this.rollDie(1,rollNum);
					}
					rollTotal += roll;
					diceIntGroup.push(roll);
				}
			}
			return { diceGroup : diceIntGroup, rollTotal : rollTotal, exploded : exploded};
		}
		return { diceGroup : diceIntGroup, rollTotal : rollTotal, exploded : exploded};
	}
	,literalValue: function(rollValue) {
		var rollRegex = new RegExp("^([1-8])$").exec(rollValue);
		var rollNum = 0;
		if(rollRegex == null) {
			this.handleError(rollValue);
		} else {
			if(rollRegex[1] != null) {
				rollNum = Std.parseInt(rollRegex[1]);
			} else {
				this.handleError(rollValue);
			}
			return { rollValue : rollNum};
		}
		return { rollValue : rollNum};
	}
};
var utils_Routes = function() { };
utils_Routes.route = function(app) {
	app.post("/roll",function(req,res) {
		var mathUtil = new utils_MathUtil(res);
		var type = req.body.type;
		var payload = req.body.payload;
		switch(type) {
		case "DICE_ROLL":
			res.json(mathUtil.rollDice(payload.rollValue));
			break;
		case "DROP_LOWEST_ROLLS":
			res.json(mathUtil.dropLowestRolls(payload.rollValue));
			break;
		case "EXPLOSIVE_ROLL":
			res.json(mathUtil.explosiveRoll(payload.rollValue));
			break;
		case "KEEP_HIGHEST_ROLLS":
			res.json(mathUtil.keepHighestRolls(payload.rollValue));
			break;
		case "LITERAL_VALUE":
			res.json(mathUtil.literalValue(payload.rollValue));
			break;
		case "ONE_DIE_ROLL":
			res.json(mathUtil.oneDieRoll(payload.rollValue));
			break;
		default:
			console.log("No type submitted.");
		}
	});
};
function $iterator(o) { if( o instanceof Array ) return function() { return HxOverrides.iter(o); }; return typeof(o.iterator) == 'function' ? $bind(o,o.iterator) : o.iterator; }
var $_, $fid = 0;
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $fid++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = function(){ return f.method.apply(f.scope, arguments); }; f.scope = o; f.method = m; o.hx__closures__[m.__id__] = f; } return f; }
Server.main();
})();

//# sourceMappingURL=server.js.map